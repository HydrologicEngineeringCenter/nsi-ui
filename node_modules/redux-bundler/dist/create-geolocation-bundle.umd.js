(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('redux-bundler/dist/create-async-resource-bundle'), require('redux-bundler')) :
  typeof define === 'function' && define.amd ? define(['redux-bundler/dist/create-async-resource-bundle', 'redux-bundler'], factory) :
  (global.reduxBundler = factory(global.createAsyncResourceBundle,global.reduxBundler));
}(this, (function (createAsyncResourceBundle,reduxBundler) {
  createAsyncResourceBundle = createAsyncResourceBundle && createAsyncResourceBundle.hasOwnProperty('default') ? createAsyncResourceBundle['default'] : createAsyncResourceBundle;

  var getError = function (message, permanent) {
    if ( permanent === void 0 ) permanent = false;

    var err = new Error(message);
    if (permanent) { err.permanent = true; }
    return err;
  };

  var geoErrorArray = ['An unknown geolocation error occured', 'Geolocation permission denied', 'Geolocation unavailable', 'Geolocation request timed out'];
  var defaultOpts = {
    timeout: 60000,
    enableHighAccuracy: false,
    persist: true,
    staleAfter: 900000,
    // fifteen minutes
    retryAfter: 60000 // one minute,

  };
  var createGeolocationBundle = (function (spec) {
    var opts = Object.assign({}, defaultOpts, spec);
    return createAsyncResourceBundle({
      name: 'geolocation',
      actionBaseType: 'GEOLOCATION_REQUEST',
      getPromise: function () { return new Promise(function (resolve, reject) {
        if (!reduxBundler.IS_BROWSER || !navigator.geolocation) {
          reject(getError('Geolocation not supported', true));
        }

        var success = function (position) {
          var res = {};
          var coords = position.coords;

          for (var key in coords) {
            res[key] = coords[key];
          }

          res.timestamp = position.timestamp;
          resolve(res);
        };

        var fail = function (ref) {
          var code = ref.code;

          reject(getError(geoErrorArray[code], code === 1));
        };

        var geoOpts = {
          timeout: opts.timeout,
          enableHighAccuracy: opts.enableHighAccuracy
        };
        navigator.geolocation.getCurrentPosition(success, fail, geoOpts);
      }); },
      persist: opts.persist,
      staleAfter: opts.staleAfter,
      retryAfter: opts.retryAfter
    });
  });

  return createGeolocationBundle;

})));
