import { createSelector } from 'redux-bundler';

var defaultOpts = {
  actionBaseType: null,
  staleAfter: 900000,
  // fifteen minutes
  retryAfter: 60000,
  // one minute,
  expireAfter: Infinity,
  checkIfOnline: true,
  persist: true
};
var createAsyncResourceBundle = (function (spec) {
  var opts = Object.assign({}, defaultOpts, spec);

  if (process.env.NODE_ENV !== 'production') {
    var requiredOptions = ['name', 'getPromise'];
    requiredOptions.forEach(function (requiredOption) {
      if (!opts[requiredOption]) {
        throw Error(("You must supply a " + requiredOption + " option when creating a resource bundle."));
      }
    });
  }

  var name = opts.name;
  var staleAfter = opts.staleAfter;
  var retryAfter = opts.retryAfter;
  var actionBaseType = opts.actionBaseType;
  var checkIfOnline = opts.checkIfOnline;
  var expireAfter = opts.expireAfter;
  var uCaseName = name.charAt(0).toUpperCase() + name.slice(1);
  var baseType = actionBaseType || name.toUpperCase(); // build selectors

  var inputSelectorName = "select" + uCaseName + "Raw";
  var dataSelectorName = "select" + uCaseName;
  var lastSuccessSelectorName = "select" + uCaseName + "LastSuccess";
  var isExpiredSelectorName = "select" + uCaseName + "IsExpired";
  var lastErrorSelectorName = "select" + uCaseName + "LastError";
  var isStaleSelectorName = "select" + uCaseName + "IsStale";
  var isWaitingToRetrySelectorName = "select" + uCaseName + "IsWaitingToRetry";
  var isLoadingSelectorName = "select" + uCaseName + "IsLoading";
  var failedPermanentlySelectorName = "select" + uCaseName + "FailedPermanently";
  var shouldUpdateSelectorName = "select" + uCaseName + "ShouldUpdate"; // action types

  var actions = {
    STARTED: (baseType + "_FETCH_STARTED"),
    FINISHED: (baseType + "_FETCH_FINISHED"),
    FAILED: (baseType + "_FETCH_FAILED"),
    CLEARED: (baseType + "_CLEARED"),
    OUTDATED: (baseType + "_OUTDATED"),
    EXPIRED: (baseType + "_EXPIRED")
  }; // action creators

  var doFetchError = function (error) { return ({
    type: actions.FAILED,
    error: error
  }); };

  var doMarkAsOutdated = function () { return ({
    type: actions.OUTDATED
  }); };

  var doClear = function () { return ({
    type: actions.CLEARED
  }); };

  var doExpire = function () { return ({
    type: actions.EXPIRED
  }); };

  var doFetchSuccess = function (payload) { return ({
    type: actions.FINISHED,
    payload: payload
  }); };

  var doFetchData = function () { return function (args) {
    var dispatch = args.dispatch;
    dispatch({
      type: actions.STARTED
    });
    return opts.getPromise(args).then(function (payload) {
      dispatch(doFetchSuccess(payload));
    }, function (error) {
      dispatch(doFetchError(error));
    });
  }; };

  var initialState = {
    data: null,
    errorTimes: [],
    errorType: null,
    lastSuccess: null,
    isOutdated: false,
    isLoading: false,
    isExpired: false,
    failedPermanently: false
  };
  var result = {
    name: name,
    reducer: function (state, ref) {
      if ( state === void 0 ) state = initialState;
      var type = ref.type;
      var payload = ref.payload;
      var error = ref.error;
      var merge = ref.merge;

      if (type === actions.STARTED) {
        return Object.assign({}, state, {
          isLoading: true
        });
      }

      if (type === actions.FINISHED) {
        var updatedData;

        if (merge) {
          updatedData = Object.assign({}, state.data, payload);
        } else {
          updatedData = payload;
        }

        return Object.assign({}, state, {
          isLoading: false,
          data: updatedData,
          lastSuccess: Date.now(),
          errorTimes: [],
          errorType: null,
          failedPermanently: false,
          isOutdated: false,
          isExpired: false
        });
      }

      if (type === actions.FAILED) {
        var errorMessage = error && error.message || error;
        return Object.assign({}, state, {
          isLoading: false,
          errorTimes: state.errorTimes.concat([Date.now()]),
          errorType: errorMessage,
          failedPermanently: !!(error && error.permanent)
        });
      }

      if (type === actions.CLEARED) {
        return initialState;
      }

      if (type === actions.EXPIRED) {
        return Object.assign({}, initialState, {
          isExpired: true,
          errorTimes: state.errorTimes,
          errorType: state.errorType
        });
      }

      if (type === actions.OUTDATED) {
        return Object.assign({}, state, {
          isOutdated: true
        });
      }

      return state;
    }
  };
  result[inputSelectorName] = function (state) { return state[name]; };
  result[dataSelectorName] = createSelector(inputSelectorName, function (root) { return root.data; });
  result[isStaleSelectorName] = createSelector(inputSelectorName, lastSuccessSelectorName, 'selectAppTime', function (state, time, appTime) {
      if (state.isOutdated) {
        return true;
      }

      if (!time) {
        return false;
      }

      return appTime - time > staleAfter;
    });
  result[isExpiredSelectorName] = createSelector(inputSelectorName, function (root) { return root.isExpired; });
  result[lastErrorSelectorName] = createSelector(inputSelectorName, function (resource) { return resource.errorTimes.slice(-1)[0] || null; });
  result[lastSuccessSelectorName] = createSelector(inputSelectorName, function (root) { return root.lastSuccess; });
  result[isWaitingToRetrySelectorName] = createSelector(lastErrorSelectorName, 'selectAppTime', function (time, appTime) {
      if (!time) {
        return false;
      }

      return appTime - time < retryAfter;
    });
  result[isLoadingSelectorName] = createSelector(inputSelectorName, function (resourceState) { return resourceState.isLoading; });
  result[failedPermanentlySelectorName] = createSelector(inputSelectorName, function (resourceState) { return resourceState.failedPermanently; });
  result[shouldUpdateSelectorName] = createSelector(isLoadingSelectorName, failedPermanentlySelectorName, isWaitingToRetrySelectorName, dataSelectorName, isStaleSelectorName, 'selectIsOnline', function (isLoading, failedPermanently, isWaitingToRetry, data, isStale, isOnline) {
      if (checkIfOnline && !isOnline || isLoading || failedPermanently || isWaitingToRetry) {
        return false;
      }

      if (data === null) {
        return true;
      }

      return isStale;
    });
  result[("doFetch" + uCaseName)] = doFetchData;
  result[("doMark" + uCaseName + "AsOutdated")] = doMarkAsOutdated;
  result[("doClear" + uCaseName)] = doClear;
  result[("doExpire" + uCaseName)] = doExpire;

  if (opts.persist) {
    result.persistActions = [actions.FINISHED, actions.EXPIRED, actions.OUTDATED, actions.CLEARED];
  }

  if (expireAfter !== Infinity) {
    result[("reactExpire" + uCaseName)] = createSelector(lastSuccessSelectorName, 'selectAppTime', function (time, appTime) {
      if (!time) {
        return false;
      }

      if (appTime - time > expireAfter) {
        return doExpire();
      }
    });
  }

  return result;
});

export default createAsyncResourceBundle;
