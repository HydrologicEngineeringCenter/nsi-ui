{"ast":null,"code":"var Store = function Store(dbName, storeName) {\n  if (dbName === void 0) dbName = 'keyval-store';\n  if (storeName === void 0) storeName = 'keyval';\n  this.storeName = storeName;\n  this._dbp = new Promise(function (resolve, reject) {\n    var openreq = indexedDB.open(dbName, 1);\n\n    openreq.onerror = function () {\n      return reject(openreq.error);\n    };\n\n    openreq.onsuccess = function () {\n      return resolve(openreq.result);\n    };\n\n    openreq.onupgradeneeded = function () {\n      openreq.result.createObjectStore(storeName);\n    };\n  });\n};\n\nStore.prototype._withIDBStore = function _withIDBStore(type, callback) {\n  var this$1 = this;\n  return this._dbp.then(function (db) {\n    return new Promise(function (resolve, reject) {\n      var transaction = db.transaction(this$1.storeName, type);\n\n      transaction.oncomplete = function () {\n        return resolve();\n      };\n\n      transaction.onabort = transaction.onerror = function () {\n        return reject(transaction.error);\n      };\n\n      callback(transaction.objectStore(this$1.storeName));\n    });\n  });\n};\n\nvar store;\n\nfunction getDefaultStore() {\n  if (!store) {\n    store = new Store();\n  }\n\n  return store;\n}\n\nfunction get(key, store) {\n  if (store === void 0) store = getDefaultStore();\n  var req;\n  return store._withIDBStore('readonly', function (store) {\n    req = store.get(key);\n  }).then(function () {\n    return req.result;\n  });\n}\n\nfunction set(key, value, store) {\n  if (store === void 0) store = getDefaultStore();\n  return store._withIDBStore('readwrite', function (store) {\n    store.put(value, key);\n  });\n}\n\nfunction del(key, store) {\n  if (store === void 0) store = getDefaultStore();\n  return store._withIDBStore('readwrite', function (store) {\n    store.delete(key);\n  });\n}\n\nfunction clear(store) {\n  if (store === void 0) store = getDefaultStore();\n  return store._withIDBStore('readwrite', function (store) {\n    store.clear();\n  });\n}\n\nfunction keys(store) {\n  if (store === void 0) store = getDefaultStore();\n  var keys = [];\n  return store._withIDBStore('readonly', function (store) {\n    (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\n      if (!this.result) {\n        return;\n      }\n\n      keys.push(this.result.key);\n      this.result.continue();\n    };\n  }).then(function () {\n    return keys;\n  });\n}\n\nvar idbKeyVal = {\n  Store: Store,\n  get: get,\n  set: set,\n  del: del,\n  clear: clear,\n  keys: keys\n};\nvar defaultOpts = {\n  maxAge: Infinity,\n  version: 0,\n  lib: idbKeyVal\n};\n\nvar getOpts = function (passedOptions) {\n  return Object.assign({}, defaultOpts, passedOptions);\n};\n\nvar keyValLib = idbKeyVal;\n\nvar get$1 = function (key, opts, store) {\n  var ref = getOpts(opts);\n  var maxAge = ref.maxAge;\n  var version = ref.version;\n  var lib = ref.lib;\n  return lib.get(key, store).then(JSON.parse).then(function (parsed) {\n    var age = Date.now() - parsed.time;\n\n    if (age > maxAge || version !== parsed.version) {\n      lib.del(key, store);\n      return null;\n    }\n\n    return parsed.data;\n  }).catch(function () {\n    return null;\n  });\n};\n\nvar set$1 = function (key, data, spec, store) {\n  var ref = getOpts(spec);\n  var lib = ref.lib;\n  var version = ref.version;\n  return lib.set(key, JSON.stringify({\n    version: version,\n    time: Date.now(),\n    data: data\n  }), store).catch(function () {\n    return null;\n  });\n};\n\nvar getAll = function (spec, store) {\n  var opts = getOpts(spec);\n  var keys$$1;\n  return opts.lib.keys(store).then(function (retrievedKeys) {\n    keys$$1 = retrievedKeys;\n    return Promise.all(keys$$1.map(function (key) {\n      return get$1(key, opts, store);\n    }));\n  }).then(function (data) {\n    return data.reduce(function (acc, bundleData, index) {\n      if (bundleData) {\n        acc[keys$$1[index]] = bundleData;\n      }\n\n      return acc;\n    }, {});\n  }).catch(function () {});\n};\n\nvar getConfiguredCache = function (spec) {\n  var opts = getOpts(spec);\n  var store;\n\n  if (opts.name) {\n    store = new Store(opts.name, opts.name);\n  }\n\n  return {\n    get: function (key) {\n      return get$1(key, opts, store);\n    },\n    set: function (key, val) {\n      return set$1(key, val, opts, store);\n    },\n    getAll: function () {\n      return getAll(opts, store);\n    },\n    del: function (key) {\n      return opts.lib.del(key, store);\n    },\n    clear: function () {\n      return opts.lib.clear(store);\n    },\n    keys: function () {\n      return opts.lib.keys(store);\n    }\n  };\n};\n\nexport { keyValLib, get$1 as get, set$1 as set, getAll, getConfiguredCache };","map":{"version":3,"sources":["index.js(original)"],"names":[],"mappings":"AAAA,IAAA,KAAA,GAAY,SAAA,KAAA,CAAe,MAAf,EAAe,SAAf,EAAe;AAE3B,MAAM,MAAA,KAAc,KAAA,CAApB,EAAoB,MAAA,GAAA,cAAA;AAAE,MAAA,SAAF,KAAA,KAAA,CAAE,EAAF,SAAA,GAAA,QAAA;AAAgC,OAAK,SAAL,GAAK,SAAL;;AAC9C,QAAA,OAAU,GAAA,SAAA,CAAA,IAAA,CAAiB,MAAjB,EAAiB,CAAjB,CAAV;;AAEC,IAAA,OAAM,CAAA,OAAN,GAAkB,YAAA;AAAA,aAAA,MAAA,CAAA,OAAA,CAAA,KAAA,CAAA;AAAA,KAAlB;;AAEA,IAAA,OAAM,CAAA,SAAN,GAAY,YAAsB;AAAA,aAAA,OAAA,CAAA,OAAA,CAAA,MAAA,CAAA;AAAA,KAAlC;;AACL,IAAA,OAAQ,CAAA,eAAR,GAAiC,YAAQ;AAClC,MAAA,OACA,CAAA,MADA,CAAA,iBAAA,CAAA,SAAA;AAIH,KALJ;AAMI,G;AACE,CAfR;;MAgBQ,S,CAAA,a,GAAO,SAAA,aAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACf,MAAA,MAAA,GAAA,IAAA;AARS,SAAA,KAWE,IAXF,CAWQ,IAXR,CAWQ,UAAA,EAAA,EAAA;AAAA,WAAA,IAAA,OAAA,CAAA,UAAA,OAAA,EAAA,MAAA,EAAA;AACjB,UAAA,WAAA,GAAA,EAAA,CAAA,WAAA,CAAA,MAAA,CAAA,SAAA,EAAA,IAAA,CAAA;;AAEO,MAAA,WAAM,CAAO,UAAb,GAAY,YAAA;AAA4B,eAAA,OAAA,EAAA;AAAA,OAAxC;;AACL,MAAA,WAAa,CAAA,OAAb,GAAyB,WAAQ,CAAA,OAAR,GAAQ,YAAA;AAAA,eAAA,MAAA,CAAA,WAAA,CAAA,KAAA,CAAA;AAAA,OAAjC;;AACA,MAAA,QACG,CADI,WAGH,CAAA,WAHG,CAGY,MAAA,CAAA,SAHZ,CACJ,CADH;AAIM,KATS,CAAA;AAQI,GAnBZ,CAAA;AAmBY,C;;IAGb,K;;AAEF,SARG,eAQH,GAEW;AACjB,MAAA,CAAA,KAAA,EAEO;AAAA,IAAA,KAAM,GAAA,IAAA,KAAA,EAAN;AAAe;;AACpB,SAAM,KAAN;AACA;;AAII,SAAA,GAAA,CAAA,GAAA,EAAO,KAAP,EAAO;AACP,MAAA,KAAA,KAAO,KAAA,CAAP,EAAmB,KAAA,GAAS,eAAW,EAApB;MAIjB,G;SACE,KAAI,CAAJ,aAAA,CAAmB,UAAnB,EAAmB,UAAA,KAAA,EAAA;AAC7B,IAAA,GAAA,GAAA,KAAA,CAAA,GAAA,CAAA,GAAA,CAAA;GADU,EAEF,IAFE,CAEF,YAAO;AAAA,WAAA,GAAA,CAAA,MAAA;AAAA,GAFL,C;AATD;;AAiBT,SAAO,GAAP,CAAa,GAAb,EAAa,KAAb,EAAa,KAAb,EAAa;AACX,MAAA,KAAM,KAAO,KAAA,CAAb,EAAqB,KAAA,GAAA,eAAA,EAAA;AAErB,SAAI,KAAK,CAAA,aAAL,CAAW,WAAX,EAAW,UAAA,KAAA,EAAA;AACb,IAAA,KAAA,CAAA,GAAA,CAAQ,KAAR,EAAQ,GAAR;AACJ,GAFM,CAAJ;AAGA;;AAEE,SAAA,GAAA,CAAA,GAAA,EAAK,KAAL,EAFK;AAGL,MAAA,KAAA,KAAQ,KAAM,CAAd,EAAc,KAAO,GAHhB,eAAA,EAGS;AAEd,SAAA,KAAA,CAAA,aAAA,CALK,WAKL,EALK,UAAA,KAAA,EAAA;AAML,IAAA,KAAA,CAAA,MAAA,CAAY,GAAZ;GADA,CAAA;AAGJ","sourcesContent":["import * as idbKeyVal from './idb-keyval'\n\nconst defaultOpts = { maxAge: Infinity, version: 0, lib: idbKeyVal }\nconst getOpts = passedOptions => Object.assign({}, defaultOpts, passedOptions)\n\nexport const keyValLib = idbKeyVal\n\nexport const get = (key, opts, store) => {\n  const { maxAge, version, lib } = getOpts(opts)\n  return lib\n    .get(key, store)\n    .then(JSON.parse)\n    .then(parsed => {\n      const age = Date.now() - parsed.time\n      if (age > maxAge || version !== parsed.version) {\n        lib.del(key, store)\n        return null\n      }\n      return parsed.data\n    })\n    .catch(() => null)\n}\n\nexport const set = (key, data, spec, store) => {\n  const { lib, version } = getOpts(spec)\n  return lib\n    .set(\n      key,\n      JSON.stringify({\n        version,\n        time: Date.now(),\n        data\n      }),\n      store\n    )\n    .catch(() => null)\n}\n\nexport const getAll = (spec, store) => {\n  const opts = getOpts(spec)\n  let keys\n  return opts.lib\n    .keys(store)\n    .then(retrievedKeys => {\n      keys = retrievedKeys\n      return Promise.all(keys.map(key => get(key, opts, store)))\n    })\n    .then(data =>\n      data.reduce((acc, bundleData, index) => {\n        if (bundleData) {\n          acc[keys[index]] = bundleData\n        }\n        return acc\n      }, {})\n    )\n    .catch(() => {})\n}\n\nexport const getConfiguredCache = spec => {\n  const opts = getOpts(spec)\n  let store\n  if (opts.name) {\n    store = new idbKeyVal.Store(opts.name, opts.name)\n  }\n  return {\n    get: key => get(key, opts, store),\n    set: (key, val) => set(key, val, opts, store),\n    getAll: () => getAll(opts, store),\n    del: key => opts.lib.del(key, store),\n    clear: () => opts.lib.clear(store),\n    keys: () => opts.lib.keys(store)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}