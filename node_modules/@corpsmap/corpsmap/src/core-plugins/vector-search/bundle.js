import values from 'lodash/values';

export default {
  name: 'vectorSearch',

  getReducer(){
    const initialData = {
      shouldRegister: true,
      shouldHandleSelect: false,
      selectedItem: null
    }

    return (state = initialData, { type, payload }) => {

      if(type === 'SEARCH_ITEM_SELECTED'){
        if(payload.selected.provider && payload.selected.provider === 'vectorSearch'){
          return Object.assign({}, state, {
            shouldHandleSelect: true,
            selectedItem: payload.selected
          })
        }
      }

      switch(type){
        case 'VECTOR_SEARCH_REGISTERED':
        case 'VECTOR_SEARCH_HANDLED_SELECT':
          return Object.assign({}, state, payload);
        default:
          return state;
      }

    }
  },

  doVectorSearchRegister: () => ({dispatch, store}) => {
    dispatch({ type: 'VECTOR_SEARCH_REGISTERED', payload: { shouldRegister: false }});
    store.doSearchAddCollection({
      onFireSearch: store.doVectorSearchFireSearch
    })
  },

  doVectorSearchHandleSelect: () => ({dispatch, store}) => {
    dispatch({ type: 'VECTOR_SEARCH_HANDLED_SELECT', payload: { shouldHandleSelect: false }});
    const selectedItem = store.selectVectorSearchLastSelected();
    if(selectedItem){
      store.doZoomToExtent(selectedItem.geometry);
    }
  },

  doVectorSearchFireSearch: (callback) => ({dispatch, store, apiGet}) => {
    let q = store.selectSearchQueryString();
    if(q.length < 2) return;
    const matcher = new RegExp(q, 'ig');
    const matches = {};
    const layers = store.selectLayers();
    Object.keys(layers).forEach((key) => {
      if(layers[key].mapLayer && layers[key].mapLayer.getType() === 'VECTOR'){
        const lyrName = layers[key].displayName;
        const src = layers[key].mapLayer.getSource();
        src.forEachFeature((feature) => {
          const props = values(feature.getProperties());
          const searched = props.filter((val) => {
            if(val) return matcher.test(val);
            return false;
          });
          if(searched.length){
            matches[`${searched[0]} (${lyrName})`] = feature;
          }
        })
      }
    })
    return callback(null, Object.keys(matches).map((key) => {
      const f = matches[key];
      return {
        provider: 'vectorSearch',
        displayName: key,
        iconClass: 'mdi mdi-map-marker-radius',
        geometry: f.getGeometry(),
        properties: f.getProperties()
      }
    }));  
  },

  selectVectorSearchLastSelected: (state) => {
    return state.vectorSearch.selectedItem;
  },

  reactVectorSearchShouldHandleSelect: (state) => {
    if(state.vectorSearch.shouldHandleSelect) return { actionCreator: 'doVectorSearchHandleSelect' };
  },

  reactVectorSearchShouldRegister: (state) => {
    if(state.vectorSearch.shouldRegister) return { actionCreator: 'doVectorSearchRegister' };
  }

}