import GeoJSON from 'ol/format/GeoJSON';
import FileSaver from 'file-saver';
import { createSelector } from 'redux-bundler';

const geoJSON = new GeoJSON();

export default {
  name: 'drawSave',

  getReducer: () => {
    const initialData = {
      points: null,
      lines: null,
      polygons: null,
      isSaving: false,
      shouldSave: false,
      lastDownload: null,
      shouldInitialize: false
    }
      
    return (state = initialData, { type, payload }) => {
      switch(type){
        case 'DRAW_SAVE_START':
        case 'DRAW_SAVE_COMPLETE':
        case 'DRAW_CACHE_START':
        case 'DRAW_CACHE_COMPLETE':
        case 'DRAW_DOWNLOAD_COMPLETE':
        case 'DRAW_SAVE_INITIALIZE_START':
        case 'DRAW_SAVE_INITIALIZE_FINISHED':
          return Object.assign({}, state, payload);
        case 'MAP_INITIALIZED':
          return Object.assign({}, state, {
            shouldInitialize: true
          })
        default:
          return state;
      }
    }
  },

  doDrawSaveInitialize: () => ({ dispatch }) => {
    // since we're not actually doing anything, just finish
    dispatch({
      type: 'DRAW_SAVE_INITIALIZE_FINISHED',
      payload: {
        shouldInitialize: false
      }
    })
  },

  doDrawSave: () => ({ dispatch, store }) => {
    dispatch({
      type: 'DRAW_SAVE_START',
      payload: {
        isSaving: true,
        shouldSave: false
      }
    })

    const ptLayer = store.selectDrawPointsLayer();
    const lineLayer = store.selectDrawLinesLayer();
    const polyLayer = store.selectDrawPolygonsLayer();

    const points = geoJSON.writeFeatures(ptLayer.getSource().getFeatures(), {
      featureProjection: store.selectMapProjection(),
      dataProjection: store.selectGeoProjection()
    });
    const lines = geoJSON.writeFeatures(lineLayer.getSource().getFeatures(), {
      featureProjection: store.selectMapProjection(),
      dataProjection: store.selectGeoProjection()
    });
    const polygons = geoJSON.writeFeatures(polyLayer.getSource().getFeatures(), {
      featureProjection: store.selectMapProjection(),
      dataProjection: store.selectGeoProjection()
    });

    dispatch({
      type: 'DRAW_SAVE_COMPLETE',
      payload: {
        isSaving: false,
        points: points,
        lines: lines,
        polygons: polygons
      }
    })
  },

  doDrawSaveDownload: () => ({ dispatch, store }) => {
    const hasPoints = store.selectDrawSaveCachePointHasFeatures()
    const hasLines = store.selectDrawSaveCacheLineStringHasFeatures()
    const hasPolys = store.selectDrawSaveCachePolygonHasFeatures()
    const timestamp = new Date().toISOString();
    const cache = store.selectDrawSaveCache();
    if(!Blob) return null;
    if(hasPoints){
      const ptData = new Blob([cache.points], { type: 'text/plain;charset=utf-8'});
      FileSaver.saveAs(ptData, `corpsmap-points-${timestamp}.geojson`);
    }
    if(hasLines){
      const lineData = new Blob([cache.lines], { type: 'text/plain;charset=utf-8'});
      FileSaver.saveAs(lineData, `corpsmap-lines-${timestamp}.geojson`);
    }
    if(hasPolys){
      const polyData = new Blob([cache.polygons], { type: 'text/plain;charset=utf-8'});
      FileSaver.saveAs(polyData, `corpsmap-polygons-${timestamp}.geojson`);
    }
    dispatch({
      type: 'DRAW_DOWNLOAD_COMPLETE',
      payload: {
        lastDownload: timestamp
      }
    })
  },

  selectDrawSaveLastDownload: (state) => {
    return state.drawSave.lastDownload;
  },

  selectDrawSaveAll: (state) => {
    return state.drawSave;
  },

  selectDrawSavePostAttempts: (state) => {
    return state.drawSave.postAttempts;
  },

  selectDrawSaveCache: (state) => {
    return {
      points: state.drawSave.points,
      lines: state.drawSave.lines,
      polygons: state.drawSave.polygons
    }
  },

  selectDrawSaveCachePoint: (state) => {
    return JSON.parse(state.drawSave.points)
  },

  selectDrawSaveCachePointHasFeatures: createSelector(
    'selectDrawSaveCachePoint',
    (fc) => {
      if(fc && fc.features && fc.features.length) return true;
      return false;
    }
  ),

  selectDrawSaveCacheLineString: (state) => {
    return JSON.parse(state.drawSave.lines);
  },

  selectDrawSaveCacheLineStringHasFeatures: createSelector(
    'selectDrawSaveCacheLineString',
    (fc) => {
      if(fc && fc.features && fc.features.length) return true;
      return false;
    }
  ),

  selectDrawSaveCachePolygon: (state) => {
    return JSON.parse(state.drawSave.polygons);
  },

  selectDrawSaveCachePolygonHasFeatures: createSelector(
    'selectDrawSaveCachePolygon',
    (fc) => {
      if(fc && fc.features && fc.features.length) return true;
      return false;
    }
  ),

  reactDrawSaveShouldSave: (state) => {
    if(state.drawSave.shouldSave) return { actionCreator: 'doDrawSave' };
  },

  reactDrawSaveShouldInitialize: (state) => {
    if(state.drawSave.shouldInitialize) return { actionCreator: 'doDrawSaveInitialize' };
  },

  persistActions: ['DRAW_SAVE_COMPLETE']

}