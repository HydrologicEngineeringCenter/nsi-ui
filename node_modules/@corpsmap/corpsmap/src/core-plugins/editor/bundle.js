import React from 'react';
import { createSelector } from 'redux-bundler'
import { getLayer } from '../../openlayers-utils/layer-utilities';
import { transformExtent } from '../../openlayers-utils/map-utils';
import createInteraction from '../../openlayers-utils/interaction-creator';
import toBboxPolygon from '@turf/bbox-polygon';
import GeoJSON from 'ol/format/GeoJSON';
import EditorTable from './editor-table';
import DateEditor from './date-editor';
import DateFormatter from './date-formatter';
import NumberEditor from './number-editor';
import StringEditor from './string-editor';

const notifications = {
  'api-success':{
    title: 'Editor Notification',
    message: 'Features saved',
    level: 'success'
  },
  'api-locks-warning':{
    title: 'Editor Notification',
    message: '{count} features could not be loaded because they are already locked',
    level: 'warning'
  },
  'api-error':{
    title: 'Editor Notification',
    message: 'Error saving edits, see console for more information',
    level: 'error'
  }
}

const geometryTypeMap = {
  'POINT':'Point',
  'LINE': 'LineString',
  'POLYGON': 'Polygon'
}

const editor = {};

export default {
  name: 'editor',
  
  getReducer(){
    const initialData = {
      mode: 'select',
      loadedEditableLayerList: false,
      editableDatasets: [],
      editing: false,
      dirty: false,
      error: null,
      currentlyEditing: null,
      geometryType: null,
      editorMapLayer: null,
      dataset: null,
      err: null,
      metadata: null,
      result: null,
      features: [],
      selected: []
    }

    return (state = initialData, { type, payload }) => {

      if(type === 'EDITOR_START'){
        return Object.assign({}, state, {
          editing: true,
          currentlyEditing: payload.layer,
          editorMapLayer: payload.mapLayer,
          geometryType: payload.geometryType
        })
      }

      if(type === 'EDITOR_STOP'){
        return Object.assign({}, state, {
          editing: false,
          dirty: false,
          currentlyEditing: null,
          editorMapLayer: null
        })
      }

      if(type === 'EDITOR_LOADED_EDITABLE'){
        return Object.assign({}, state, {
          loadedEditableLayerList: true,
          editableDatasets: payload.editableDatasets
        })
      }

      if(type === 'EDITOR_LOADING_EDITABLE'){
        return Object.assign({}, state, {
          loadedEditableLayerList: true
        })
      }

      if(type === 'EDITOR_LOADED_EDITABLE_ERROR'){
        return Object.assign({}, state, {
          error: payload
        })
      }

      if(type === 'EDITOR_FEATURES_LOADED'){
        return Object.assign({}, state, payload);
      }

      if(type === 'EDITOR_MARK_DIRTY'){
        return Object.assign({}, state, {
          dirty: true
        })
      }

      if(type === 'EDITOR_SAVE_SUCCESS'){
        return Object.assign({}, state, {
          dirty: false
        })
      }

      if(type === 'EDITOR_MODE_SWITCH'){
        return Object.assign({}, state, payload);
      }

      if(type === 'EDITOR_PAUSE'){
        return Object.assign({}, state, {
          mode: null
        })
      }

      if(type === 'EDITOR_UPDATE_SELECTION'){
        return Object.assign({}, state, payload);
      }

      return state;
    }
  },

  doStartEditing: (layer) => ({dispatch, store}) => {
    store.doSetCursor('wait');
    const map = store.selectMap();
    const geometryType = geometryTypeMap[layer.geometryType];
    const mapLayer = getLayer({
      serviceType: 'LocalVector',
      visible: true,
      geometryType: geometryType
    })
    map.addLayer(mapLayer);
    
    editor.src = mapLayer.getSource();

    mapLayer.getSource().on(['addfeature','removefeature'], (e) => { 
      console.log('caught edit', e)
    });

    editor.deleted = [];

    editor.draw = createInteraction({
      interaction: 'draw',
      source: editor.src,
      type: geometryType
    })

    editor.select = window.select = createInteraction({
      interaction: 'select',
      layers: [ mapLayer ]
    })
    editor.select.on('select', store.doUpdateEditorSelection);

    editor.modify = createInteraction({
      interaction: 'modify',
      features: editor.select.getFeatures()
    })

    editor.snap = createInteraction({
      interaction: 'snap',
      source: editor.src
    })

    store.doAddEditorInteractions();

    dispatch({type:'EDITOR_START', payload: { layer, mapLayer, geometryType }});

    store.doLoadEditFeatures();
    store.doSouthRegionOpen({component: EditorTable, options:{}, openedBy: 'editing-tools', displayName: 'EDIT ' + layer.displayName});
    window.addEventListener('onbeforeunload', store.doConfirmPageUnload)
  },

  doConfirmPageUnload: (e) => ({dispatch, store}) => {
    var dialogText = 'Dialog text here';
    e.returnValue = dialogText;
    return dialogText;
  },

  doUpdateEditorSelection: () => ({dispatch}) => {
    const features = editor.select.getFeatures().getArray();
    const selected = features.map((feature) => {
      return feature.ol_uid;
    })
    dispatch({type:'EDITOR_UPDATE_SELECTION', payload: { selected }})
  },

  doAddToEditorSelection: (selected) => ({dispatch, store}) => {
    const features = editor.src.getFeatures().filter((feature) => {
      return selected.indexOf(feature.ol_uid) !== -1;
    })
    const selection = editor.select.getFeatures();
    features.forEach((feature) => {
      selection.push(feature);
    })
    store.doUpdateEditorSelection();
  },

  doRemoveFromEditorSelection: (deselected) => ({dispatch, store}) => {
    const selection = editor.select.getFeatures();
    const removeThese = [];
    selection.forEach((feature) => {
      if(feature && deselected.indexOf(feature.ol_uid) !== -1) removeThese.push(feature);
    })
    removeThese.forEach((feature) => {
      selection.remove(feature);
    })
    store.doUpdateEditorSelection();
  },

  doAddEditorInteractions: () => ({dispatch, store}) => {
    store.doRemoveEditorInteractions();
    const mode = store.selectEditorMode();
    if(mode === 'select'){
      store.doEditorSelectMode();
    }else if(mode === 'add'){
      store.doEditorAddMode();
    }
  },

  doRemoveEditorInteractions: () => ({dispatch, store}) => {
    store.doSetCursor();
    const map = store.selectMap();
    if(editor.draw)   map.removeInteraction(editor.draw);
    if(editor.select) map.removeInteraction(editor.select);
    if(editor.modify) map.removeInteraction(editor.modify);
    if(editor.snap)   map.removeInteraction(editor.snap);
    window.document.removeEventListener('keyup', store.doEditorDeleteListener)
  },

  doEditorAddMode: () => ({dispatch, store}) => {
    store.doSetCursor('crosshair');
    editor.select.getFeatures().clear();
    store.doUpdateEditorSelection();
    const map = store.selectMap();
    map.addInteraction(editor.draw);
    map.addInteraction(editor.snap);
  },

  doEditorSelectMode: () => ({dispatch, store}) => {
    store.doSetCursor('crosshair');
    const map = store.selectMap();
    map.addInteraction(editor.select);
    map.addInteraction(editor.modify);
    map.addInteraction(editor.snap);
    window.document.addEventListener('keyup', store.doEditorDeleteListener)
  },

  doEditorDeleteListener: (e) => ({dispatch, store}) => {
    if(e.keyCode === 46) store.doDeleteSelection();
  },

  doPauseEditing: () => ({dispatch, store}) => {
    store.doRemoveEditorInteractions();
    dispatch({type:'EDITOR_PAUSE'})
  },

  doStopEditing: () => ({dispatch, store}) => {
    const mapLayer = store.selectEditingMapLayer();
    const map = store.selectMap();
    map.removeLayer(mapLayer);
    store.doReleaseLocks();
    store.doRemoveEditorInteractions();
    store.doCloseSouthRegion();
    window.removeEventListener('onbeforeunload', store.doConfirmPageUnload)
    dispatch({type:'EDITOR_STOP'});
  },

  doDeleteSelection: () => ({dispatch}) => {
    const features = editor.select.getFeatures();
    features.forEach((feature) => {
      editor.deleted.push(feature);
      editor.src.removeFeature(feature);
    })
    editor.select.getFeatures().clear();
  },

  doSaveEdits: (body) => ({dispatch, store, apiPost}) => {
    const layer = store.selectCurrentlyEditing();
    const root = store.selectApiRoot();
    dispatch({type:'EDITOR_START_SAVE'});
    apiPost(
      `${root}/cop-api/editor/${layer.teamDatasetId}`,
      body, 
      (err, response, body) => {
      if(err || response.statusCode !== 200){
        console.log(err, response);
        dispatch({type:'EDITOR_SAVE_ERROR', payload: { notification: notifications['api-error']}});
      }else{
        const src = layer.mapLayer.getSource();
        const urls = src.getUrls();
        const newUrls = urls.map((url) => {
          const delim = url.indexOf('?') !== -1 ? '&' : '?';
          const d = new Date();
          return url + delim + d.getTime();
        })
        src.setUrls(newUrls);
        dispatch({type:'EDITOR_SAVE_SUCCESS', payload:{ notification: notifications['api-success'] }});
      }
    })
  },

  doLoadEditFeatures: () => ({dispatch, store, apiGet}) => {
    const layer = store.selectCurrentlyEditing();
    const mapLayer = store.selectEditingMapLayer();
    const map = store.selectMap();
    const view = store.selectView();
    const root = store.selectApiRoot();
    const webmercBounds = view.calculateExtent(map.getSize());
    const wgs84Bounds = transformExtent(webmercBounds, 'EPSG:3857', 'EPSG:4326');
    const bbox = toBboxPolygon(wgs84Bounds);
    
    apiGet(`${root}/cop-api/editor/${layer.teamDatasetId}?bbox=${bbox.geometry.coordinates.toString()}`, (err, response, body) => {
      if(err) return console.log('error getting data');
      const json = JSON.parse(body);
      if(json.dataset && json.dataset === layer.teamDatasetId){
        const geoJson = json.result[layer.teamDatasetId];

        if(geoJson){
          const features = (new GeoJSON()).readFeatures(geoJson, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
          const src = mapLayer.getSource();
          src.addFeatures(features);
        }

        if(json.err && json.err.locks){
          const config = Object.assign({}, notifications['api-locks-warning']);
          config.message = config.message.replace(/{count}/ig, json.err.locks.length);
          store.doNotificationsFire(config);
        }

        dispatch({type:'EDITOR_FEATURES_LOADED', payload: {metadata: json.metadata}})
      }
    })
  },

  doLoadEditableLayerList: () => ({dispatch, store, apiGet}) => {
    dispatch({type:'EDITOR_LOADING_EDITABLE'});
    const root = store.selectApiRoot();
    apiGet(`${root}/cop-api/editable/datasets`, (err, response, body) => {
      if(err){
        dispatch({type:'EDITOR_LOADED_EDITABLE_ERROR', payload: err})
      }else{
        dispatch({type:'EDITOR_LOADED_EDITABLE', payload: { editableDatasets: JSON.parse(body).datasets }})
      }
    })
  },

  doReleaseLocks: () => ({dispatch, store, apiDel}) => {
    const layer = store.selectCurrentlyEditing();
    const root = store.selectApiRoot();
    apiDel(`${root}/cop-api/editor/${layer.teamDatasetId}`, (err, response, body) => {
      if(response.statusCode === 200) dispatch({type: 'EDITOR_LOCKS_RELEASED'});
    })
  },

  doMarkAsDirty: () => ({dispatch}) => {
    dispatch({type:'EDITOR_MARK_DIRTY'});
  },

  doUpdateEditorMode: (mode) => ({dispatch, store}) => {
    dispatch({type:'EDITOR_MODE_SWITCH', payload:{ mode }});
    store.doAddEditorInteractions();
  },

  selectSelectedIds: (state) => {
    return state.editor.selected;
  },

  selectDeletedFeatures: (state) => {
    return editor.deleted;
  },

  selectEditorMode: (state) => {
    return state.editor.mode;
  },

  selectIsEditing: (state) => {
    return state.editor.editing;
  },

  selectCurrentlyEditing: (state) => {
    return state.editor.currentlyEditing;
  },

  selectEditingMapLayer: (state) => {
    return state.editor.editorMapLayer;
  },

  selectEditingFeatures: (state) => {
    return state.editor.features;
  },

  selectEditableDatasets: (state) => {
    return state.editor.editableDatasets;
  },

  selectEditorMetadata: (state) => {
    return state.editor.metadata;
  },

  selectEditorIsDirty: (state) => {
    return state.editor.dirty;
  },

  selectEditingGeometryType: (state) => {
    return state.editor.geometryType;
  },

  selectEditorColumns: createSelector(
    'selectEditorMetadata',
    'selectAppTime',
    (metadata, appTime) => {
      if(!metadata) return [];

      const columns = [];
      metadata.forEach((col, i) => {

        if(col.pk || col.name === 'SHAPE') return;

        const column = {
          id: i,
          key: col.name,
          name: col.name,
          editable: !col.pk,
          sortable : true,
          filterable: true,
          width: 200,
          resizable: true,
          size: col.size,
          scale: col.scale,
          nullable: col.nullable
        }

        if(col.dataType === 'TIMESTAMP'){
          column.editor = <DateEditor />;
          column.formatter = <DateFormatter />;
        }

        if(col.dataType === 'DATE'){
          column.editor = <DateEditor />
          column.formatter = <DateFormatter />
        }

        if(col.dataType === 'DECIMAL' || col.dataType === 'FLOAT'){
          column.editor = <NumberEditor />
        }

        if(col.datType === 'VARCHAR'){
          column.editor = <StringEditor />
        }
        
        columns.push(column);
      });
      return columns;
    }
  ),

  reactShouldLoadEditableList: (state) => {
    if(!state.editor.loadedEditableLayerList) return { actionCreator: 'doLoadEditableLayerList' }
  }
}