import React from 'react';
import { connect } from 'redux-bundler-react';
import { BasicToolbarButton, BasicToolbarMenu, BasicToolbarMenuItem, BasicToolbarMenuDivider, BasicToolbarSubmenu } from '../../application-controls'; 
import GeoJSON from 'ol/format/GeoJSON';
import classnames from 'classnames';

class EditorButton extends React.Component {
  constructor(props){
    super(props);
    this.fmt = new GeoJSON();
    this.saveEdits = this.saveEdits.bind(this);
    this.stopEditing = this.stopEditing.bind(this);
    this.renderEditableLayers = this.renderEditableLayers.bind(this);
    this.getToolIcon = this.getToolIcon.bind(this);
    this.updateMode = this.updateMode.bind(this);
  }

  updateMode(e){
    const { doUpdateEditorMode } = this.props;
    const mode = e.currentTarget.dataset.mode;
    doUpdateEditorMode(mode);
  }

  saveEdits(){
    const { editingMapLayer, doSaveEdits, deletedFeatures } = this.props;
    const source = editingMapLayer.getSource();
    const inserts = [];
    const updates = [];
    const deletes = [];
    source.forEachFeature(( feature ) => {
      if(feature.getId()){
        updates.push(this.fmt.writeFeatureObject(feature, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'}));
      }else{
        inserts.push(this.fmt.writeFeatureObject(feature, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'}));
      }
    })
    deletedFeatures.forEach(( feature ) => {
      deletes.push(this.fmt.writeFeatureObject(feature, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'}));
    })
    doSaveEdits({
      inserts: inserts,
      updates: updates,
      deletes: deletes
    })
  }

  stopEditing(){
    const { doStopEditing, editorIsDirty } = this.props;
    if(editorIsDirty){
      if(window.confirm('Are you sure you want to quit without saving?')){
        doStopEditing();
      }
    }else{
      doStopEditing();
    }
  }

  renderEditableLayers(){
    const { editableDatasets, layers, doStartEditing, currentlyEditing } = this.props;

    if(currentlyEditing) return null;

    const editable = [];

    Object.keys(layers).forEach((layerUid) => {
      if(layers[layerUid].teamDatasetId && editableDatasets.indexOf(layers[layerUid].teamDatasetId) !== -1){
        editable.push(layers[layerUid]);
      }
    })

    if(editable.length === 0){
      return (
        <BasicToolbarSubmenu>
          <BasicToolbarMenuItem 
            active={false}
            iconClass="mdi mdi-playlist-remove icon-inline"
            title='No editable layers available'
            text='No editable layers available'
          />
        </BasicToolbarSubmenu>
      )
    }else{
      return (
        <BasicToolbarSubmenu>
          {
            editable.map((layer) => {
              return (
                <BasicToolbarMenuItem 
                  key={layer.uid}
                  active={false}
                  iconClass="cm cm-measure-line icon-inline"
                  title='team dataset id for a layer that i can edit'
                  text={layer.displayName}
                  onClick={ () => { doStartEditing(layer) } }
                  passProps={{"data-type":"distance"}}
                />
              )
            })
          }
        </BasicToolbarSubmenu>
      )
    }
  }

  getToolIcon(){
    const { editingGeometryType } = this.props;
    return classnames({
      "mdi": true,
      "mdi-cancel": !editingGeometryType,
      "mdi-vector-point": editingGeometryType === 'Point',
      "mdi-vector-polyline": editingGeometryType === 'LineString',
      "mdi-vector-polygon": editingGeometryType === 'Polygon',
      "icon-inline": true
    })
  }

  render(){
    const { currentlyEditing, editorIsDirty, editorMode, doPauseEditing } = this.props;
    const startEditingText = !currentlyEditing ? 'Start Editing' : currentlyEditing.displayName;
    const startEditingIcon = !currentlyEditing ? 'mdi mdi-square-edit-outline icon-inline' : 'mdi mdi-rocket icon-inline';
    const dirtyStyle = editorIsDirty ? {style:{backgroundColor:'#4eb6f3',color:'white'}} : null;
    return (
      <BasicToolbarButton
        enabled={true}
        iconClass="mdi mdi-pencil"
        title="Editing Tools"
        onDeactivate={ doPauseEditing }
      >
        <BasicToolbarMenu>
          <BasicToolbarMenuItem 
            active={!!currentlyEditing}
            iconClass={startEditingIcon}
            title={startEditingText}
            text={startEditingText}
          >
            { 
              this.renderEditableLayers()
            }
          </BasicToolbarMenuItem>
          <BasicToolbarMenuDivider />
          <BasicToolbarMenuItem
            active={ editorMode === 'select' && !!currentlyEditing }
            iconClass="mdi mdi-cursor-default icon-inline"
            title="Select / Modify Features"
            text="Select / Modify Features"
            onClick={ this.updateMode }
            passProps={{"data-mode": 'select'}}
          />
          <BasicToolbarMenuItem
            active={ editorMode === 'add' && !!currentlyEditing }
            iconClass={ this.getToolIcon() }
            title="Add New Features"
            text="Add New Features"
            onClick={ this.updateMode }
            passProps={{"data-mode": 'add'}}
          />
          <BasicToolbarMenuDivider />
          <BasicToolbarMenuItem
            active={false}
            iconClass="mdi mdi-content-save icon-inline"
            title="Save Edits"
            text="Save Edits"
            onClick={  this.saveEdits }
            passProps={ dirtyStyle }
          />
          <BasicToolbarMenuItem
            active={false}
            iconClass="mdi mdi-cancel icon-inline"
            title="Stop Editing"
            text="Stop Editing"
            onClick={  this.stopEditing }
          />
        </BasicToolbarMenu>
      </BasicToolbarButton>
    )
  }
}

export default connect(
  'doStartEditing',
  'doStopEditing',
  'doPauseEditing',
  'doSaveEdits',
  'doUpdateEditorMode',
  'selectEditingGeometryType',
  'selectEditingMapLayer',
  'selectDeletedFeatures',
  'selectEditorIsDirty',
  'selectEditableDatasets',
  'selectLayers',
  'selectCurrentlyEditing',
  'selectEditorMode',
  EditorButton
);